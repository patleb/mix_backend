namespace :deploy do
  desc 'link dev shared folder'
  task :link_dev do
    on release_roles(:all) do
      next if fetch(:stage) != :vagrant
      execute :rm, '-f', current_path
      execute :ln, "-s", '/vagrant', current_path
      set :bundle_path, nil
      set :bundle_binstubs, nil
      set :bundle_jobs, nil
      set :bundle_without, nil
      set :bundle_flags, nil
      ENV['DEVELOPMENT'] = 'true'
      invoke 'bundler:install'
      invoke 'nginx:app:push', 'reload'
    end
  end

  desc 'unlink dev shared folder'
  task :unlink_dev do
    on release_roles(:all) do
      next if fetch(:stage) != :vagrant
      execute :rm, '-f', current_path
      execute :ln, '-s', "$(ls -dt #{releases_path}/* | head -1)", current_path
      invoke 'nginx:app:push', 'reload'
    end
  end

  desc 'make current path executable'
  task :make_current_path_executable do
    on release_roles(:all) do
      Pathname.new(current_path).ascend.each do |path|
        execute :sudo, :chmod, '777', path.to_s
      end
    end
  end
  after 'deploy:symlink:release', 'deploy:make_current_path_executable'

  # TODO stop batches (db mutex), wait to finish, continue with passenger-restart, start batches

  desc 'Full server deploy after provisioning'
  task push: %i(
    dns:set_localhost
    nginx:push
    deploy:app:push
    monit:push
    monit:restart
  )

  namespace :app do
    desc 'App server deploy after provisioning'
    task push: %i(
      deploy:check:directories
      deploy:check:linked_dirs
      deploy:check:make_linked_dirs
      secrets:push
      logrotate:push
      nginx:app:push
      nginx:app:enable
      nginx:app:maintenance:push
      db:pg:create_user
      db:pg:create_database
      db:pg:set_superuser
      pgrest:push
      deploy
      whenever:create_cron_log
    )
  end
end
